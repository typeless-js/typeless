---
id: createEpic
title: createEpic
hide_title: true
sidebar_label: createEpic
---

# createEpic(epicName)
Create a new epic. Epics are used for handling asynchronous side effects.

#### Arguments
1. `epicName: string`- the epic name (module name). It's used only for logging.


#### Returns
`{Epic}` - the epic.


## Epic methods
### `attach(epic)` 
Attach a child epic.
#### Arguments
1. `epic: Epic` - the epic to attach.
#### Returns
`{Epic}` - this epic.

#### Example
```ts
import { createEpic } from 'typeless';
import { mySubEpic } from './epics/subModule';

const epic = createEpic('module')
  .attach(mySubEpic)
```

---

### `on(actionCreator, handler)`
Attach a handler for the specific action creator. The action creator is a function generated by `createActions`.
#### Arguments
1. `actionCreator: ActionCreator` - the action creator. Under the hood it checks `actionCreator.toString() === action.type`.
2. `handler: (payload, { action$, getState, state$ }, action) => EpicResult`  
  The function handler with the following parameters:
   - `payload: object` - the action payload. The type is inferred automatically from ActionCreator.
   - `deps` - contains following dependencies:
      - `action$: Observable<Action>` the Rx Observable with all actions.
      - `getState: () => State` the getter for global Redux state.
      - `state$: Observable<State>` the Rx Observable with all state changes.
   - `action: object` - the original action.  

    The handler is allowed to return 3 types:
    - `Observable<Action>` - the Rx stream.
    - `Action` - the action object.
    - `Action[]` - an array of actions.
#### Returns
`{Epic}` - this epic
#### Example
```ts
import { createEpic, createActions } from 'typeless';
import * as Rx from 'typeless/rx';
import { API } from '../services/API';

const MODULE = 'module';

const UserActions = createActions(MODULE, {
  loadUser: (id: number) => ({ payload: { id } }),
  userLoaded: (user: User) => ({ payload: { user } }),
});

const epic = createEpic(MODULE)
  .on(UserActions.loadUser, ({ id }, { getState }) => {
    if (getState().user.isLoaded) {
      // already loaded, ignore
      return Rx.empty();
    }
    return API.loadUser(id).pipe(Rx.map(user => UserActions.userLoaded(user)));
  });
```


---

### `onMany(actionCreators[], handler)`
Attach a handler for multiple action creators. This function is very similar to `on`.
#### Arguments
1. `actionCreators: ActionCreator[]` - the action creators to match.
2. `handler: (payload, { action$, getState, state$ }, action) => EpicResult`  
#### Returns
`{Epic}` - this epic.
#### Example
```ts
import { createEpic, createActions } from 'typeless';
import * as Rx from 'typeless/rx';
import { API } from '../services/API';

const MODULE = 'module';

const UserActions = createActions(MODULE, {
  reloadUser: (id: number) => ({ payload: { id } }),
  loadUser: (id: number) => ({ payload: { id } }),
});

const epic = createEpic(MODULE)
  .onMany([UserActions.loadUser, UserActions.reloadUser], ({ id }) => {
    return API.loadUser(id).pipe(Rx.map(user => UserActions.userLoaded(user)));
  });
```